<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DROPBLOX</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            text-align: center;
            margin: 0 auto;
            padding: 0;
        }
        #c {
            max-width: 100%;
            height: auto;
            background-color: lightgrey;
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <div class="container py-2">
        <h1 id="title" class="text-center fw-bold">DROPBLOX</h1>

        <div class="d-flex justify-content-center gap-5">
            <h3>Score: <span id="score">0</span></h3>
            <h3>High Score: <span id="high-score">0</span></h3>
            <h3>
                <a id="settings-link" href="settings" class="fw-bold text-decoration-none text-primary">Settings</a>
            </h3>
        </div>

        <canvas id="c" width="900" height="500"></canvas>
        <h3>Lives <span id="lives">1</span></h3>
    </div>

<script src="default_settings.js"></script>
<script>

let brick_velocity, brick_y, x, y, vx, score, high_score, gap_index, brick_width, number_of_lives, block_speed;
let gaps = [];

const keys = Object.keys(default_settings);
const params = new URLSearchParams(window.location.search);
const queryParams = new URLSearchParams();

keys.forEach(key => {
    let val = params.get(key);
    if (val !== null) {
        if (typeof default_settings[key] === "number") {
            val = key === "brick_count" ? parseInt(val) : parseFloat(val);
        }
        // else keep as string
        window[key] = val;
    } else {
        window[key] = default_settings[key];
    }

    queryParams.set(key, window[key]);
});

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

[canvas.width, canvas.height, canvas.style.backgroundColor] = [canvas_width, canvas_height, canvas_colour];

document.getElementById("settings-link").href = `settings.html?${queryParams.toString()}`;

const [score_element, high_score_element, title_element, lives_element] = 
    ["score", "high-score", "title", "lives"].map(id => document.getElementById(id));

high_score = parseInt(localStorage.getItem("high_score")) || 0;
high_score_element.textContent = high_score;
lives_element.textContent = number_of_lives = Math.max(Math.floor(initial_number_of_lives), 1);

const [game_over_message, title_message] = ["PRESS ENTER OR SPACE TO PLAY",display_name];

function gap_indices(n = 1) {
    let indices = [];


    while (indices.length < n) {
        const idx = Math.floor(Math.random() * (brick_count - 1));
        if (!indices.includes(idx)) indices.push(idx);
    }
    return indices;
}

function start_game() {

    lives_element.textContent = number_of_lives = Math.max(Math.floor(initial_number_of_lives), 1);
    block_speed = initial_block_speed;

    // Canvas and player data
    [x, y] = [canvas_width/2, canvas_height-block_size];
    vx = brick_y = score = 0;

    brick_width = (canvas_width / brick_count) - gap_size;
    gaps = gap_indices(number_of_gaps);
    brick_velocity = initial_brick_velocity;

    score_element.textContent = score;
    title_element.textContent = title_message

}

function die() {
    brick_velocity = 0;
    title_element.textContent = game_over_message;
}

die();


document.addEventListener("keydown", e => {
    if (e.key === "ArrowRight" || e.key.toLowerCase() === "d") vx = block_speed;
    if (e.key === "ArrowLeft"  || e.key.toLowerCase() === "a") vx = -block_speed;
    if (brick_velocity === 0 && (e.code === "Space" || e.code === "Enter")) start_game();
});

document.addEventListener("keyup", e => {
    if (["arrowright","arrowleft","a","d"].includes(e.key.toLowerCase())) vx = 0;
});


function draw() {

    // Change position
    x = wall_mode ? (x + vx + canvas_width - block_size) % (canvas_width - block_size) : Math.min(Math.max(x + vx, 0), canvas_width - block_size);
    brick_y += brick_velocity;

    // Draw Block
    ctx.fillStyle = player_colour;
    ctx.clearRect(0, 0, canvas_width, canvas_height);
    ctx.fillRect(x, y, block_size, block_size);

    // Draw Bricks
    ctx.fillStyle = brick_colour;
    for (let i = 0; i < brick_count; i++) {
        if (!gaps.includes(i)) {
            ctx.fillRect(i * (brick_width + gap_size) + gap_size/2, brick_y, brick_width, brick_height);
        }
    }
}

function check_collision() {

    // Block has been passed. Update score and high score
    if (brick_y > canvas_height) {
        brick_y = 0;
        gaps = gap_indices(number_of_gaps);
        score_element.textContent = ++score;
        brick_velocity = brick_velocity_square*(score**2) + brick_velocity_linear*score + initial_brick_velocity;
        block_speed = block_velocity_square*(score**2) + block_velocity_linear*score + initial_block_speed;

        lives_element.textContent = (number_of_lives > 0 && score % life_regeneration_rate === 0) ? ++number_of_lives : lives_element.textContent;

        if (score > high_score) {
            high_score_element.textContent = high_score = score;
            localStorage.setItem("high_score", high_score);
        }
    }

    // Check if Block hits Brick
    for (let i = 0; i < brick_count; i++) {
        if (!gaps.includes(i)) {
            const bx = i * brick_width;
            const by = brick_y;

            const hit =
                x < bx + brick_width &&
                x + block_size/2 > bx &&
                y < by + brick_height &&
                y + block_size > by;

            if (hit) {
                brick_y = 0;
                lives_element.textContent = --number_of_lives;
                if (number_of_lives == 0) die();
            } 
        }
    }


}

function loop() {
    draw();
    check_collision();
    requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
